def printNGE(arr): 
  
    for i in range(0, len(arr)): 
  
        next = -1
        for j in range(i+1, len(arr)): 
            if arr[i] < arr[j]: 
                next = arr[j] 
                break
              
        print(str(arr[i]) + " -- " + str(next)) 
  
# Driver program to test above function 
#arr = [11,13,21,3] 
arr = [13, 7, 6, 12]
printNGE(arr) 
*********************************************************************************************************
#next gratest element
def nge(l):
    temp=l[::]
    nge=temp[-1]
    print(str(temp[-1]) + "-->" + "-1")
    for i in range(len(temp)-2,-1,-1):
        if temp[i] < nge:
            print(str(temp[i])+ "-->" + str(nge))
            temp[i]=nge
            
        else:
            
            print(str(temp[i]) + "-->" + "-1")
            nge= temp[i]

nge([1,2,3,4])
*********************************************************************************************************
#Next Greater Element I
def nextGreaterElement(nums1, nums2):
        
        stack = []
        stack= [nums2[0]]
        dic = {}
        for i in range(1,len(nums2)):
            while stack and nums2[i] > stack[-1]:
                dic[stack.pop()] = nums2[i]
            stack.append(nums2[i])

        res = []
        for num in nums1:
            if num in dic.keys():
                res.append(dic[num])
            else:
                res.append(-1)

        return res
        
nextGreaterElement([2,4],[1,2,3,4])        
*********************************************************************************************************
#Next Greater Element II
def nextGreaterElement(nums):
        
    if len(nums) == 0:
        return []
    if len(nums) == 1:
        return [-1]
    
    res = [-1] * len(nums)
    
    istack = []
    for i in range(len(nums) * 2):
        while istack and nums[i % len(nums)] > nums[istack[-1]]:
            res[istack.pop()] = nums[i % len(nums)]
        if i < len(nums):
            istack.append(i)
    
    return res
        
nextGreaterElement([3,8,4,1,2])                
*********************************************************************************************************
import random 
  
# A function to generate a random permutation of arr[] 
def randomize (arr, n): 
    # Start from the last element and swap one by one. We don't 
    # need to run for the first element that's why i > 0 
    for i in range(n): 
        # Pick a random index from 0 to i 
        j = random.randint(0,n-1) 
  
        # Swap arr[i] with the element at random index 
        arr[i],arr[j] = arr[j],arr[i] 
    return arr 
  
# Driver program to test above function. 
arr = [1, 2, 3, 4, 5, 6, 7, 8] 
n = len(arr) 
print(randomize(arr, n)) 
*********************************************************************************************************
import random
       
def sceret_santa(a):
    
    shuffel_(a)
    a.append(a[0])
    for i in range(len(a)-1):
        print ('%s:%s' % (a[i], a[i+1]))
        
def shuffel_(a):
    for i in range(len(a)):
        j=random.randint(0,len(a)-1)
        a[i],a[j]=a[j],a[i]        

sceret_santa(a=['shrvan','varun','priya','vandu','vrishti'])
*********************************************************************************************************
# Create a binary search tree from a given sorted array.
class TreeNode: 
    def __init__(self ,val): 
        self.val = val 
        self.left = None
        self.right = None
  
def buildTree(arr): 
        
    if not arr:
        return None
        
    mid = len(arr)//2    
        
    root=TreeNode(arr[mid])
    
    root.right = buildTree(arr[mid+1:])
    root.left = buildTree(arr[:mid])
    
    return root

buildTree([1,2,3,4])
*********************************************************************************************************
def partition_labels(S):

    rightmost={}
    for index,letter in enumerate(S):
        rightmost[letter]=index
        
    right=0
    left=0
    
    result=[]
    for i,letter in enumerate(S):
        
        right=max(right,rightmost[letter])
        
        if i == right:
            result.append(right-left+1)
            left = i+1
            
    return result  
    
partition_labels("ababcbacadefegdehijhklij")    
*********************************************************************************************************
import collections
def minWindow(s, t):
    need, missing = collections.Counter(t), len(t)
    i = I = J = 0
    for j, c in enumerate(s, 1):
        missing -= need[c] > 0
        need[c] -= 1
        if not missing:
            while i < j and need[s[i]] < 0:
                need[s[i]] += 1
                i += 1
            if not J or j - i <= J - I:
                I, J = i, j
    return s[I:J]
minWindow("ADOBECABODEBANC", "ABC")  

#with dictionary
def minWindow(s, t):
    need = {}
        
    for i in t:
        if i not in need:
            need[i]=1
        else:
            need[i]+=1
            
    missing = len(t)
    i=0
    I=0
    J=0
    
    for j,c in enumerate(s,1):
        if c in need:
            if need[c] > 0:
                missing -=1
        
            need[c]-=1
        else:
            need[c]=-1
        if not missing:
            
            while i<j and need[s[i]]<0:
                need[s[i]]+=1
                i+=1
            if not J or j-i < J-I:
                I=i
                J=j
      
    return s[I:J]
minWindow("aa", "aa")  
    
    
*********************************************************************************************************
def wordBreak(s, wordDict):
    
    dp = [False] * (len(s) + 1) # dp[i] means s[:i+1] can be segmented into words in the wordDicts 
    dp[0] = True
    for i in range(len(s)):
        for j in range(i, len(s)):
            temp=s[i: j+1]
            if dp[i] and s[i: j+1] in wordDict:
                dp[j+1] = True
                
    return dp[-1]
    
s="catsanddog"
wordDict=["cats","dog","sand","and","cat"]  
wordBreak(s, wordDict) 
*********************************************************************************************************
import collections
def snakesAndLadders(board):
        board_2 = [0]
        rows, cols = len(board), len(board[0])
        row = rows - 1

        while row>=0:
            for col in range(cols):
                board_2.append(board[row][col])
            row -= 1
            if row >= 0:
                for col in range(cols-1, -1, -1):
                    board_2.append(board[row][col])
                row -= 1

        visited = [0 for i in range(len(board_2))]
        stack = collections.deque()
        #stack = []
        stack.append([1,0])
        while stack:
            curr_ind, curr_dist = stack.popleft()
            for i in range(1,7):
                next_ind = min(rows*cols,curr_ind + i)
                
                if board_2[next_ind] != -1:
                    next_ind = board_2[next_ind]
                if visited[next_ind] == 1:
                    continue
                if next_ind == rows*cols:
                    return curr_dist + 1
                if visited[next_ind] == 0:
                    visited[next_ind] = 1
                    stack.append([next_ind, curr_dist + 1])

        return -1
snakesAndLadders([[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]])
*********************************************************************************************************
def restoreIpAddresses(s):
    res = []
    dfs(s, 0, "", res)
    return res
    
def dfs(s, index, path, res):
    if index == 4:
        if not s:
            res.append(path[:-1])
        return # backtracking
    for i in range(1, 4):
        # the digits we choose should no more than the length of s
        if i <= len(s):
            #choose one digit
            if i == 1: 
                dfs(s[i:], index+1, path+s[:i]+".", res)
            #choose two digits, the first one should not be "0"
            elif i == 2 and s[0] != "0": 
                dfs(s[i:], index+1, path+s[:i]+".", res)
            #choose three digits, the first one should not be "0", and should less than 256
            elif i == 3 and s[0] != "0" and int(s[:3]) <= 255:
                dfs(s[i:], index+1, path+s[:i]+".", res)
                
restoreIpAddresses("25525511135")
*********************************************************************************************************
def maximalSquare(matrix):
    
    dp=[[None]*(len(matrix[0])+1) for i in range(len(matrix)+1)]
    
    res=0
    for i in range(len(matrix)+1):
        for j in range(len(matrix[0])+1):
            
            if i==0 or j==0:
                dp[i][j]=0
            elif matrix[i-1][j-1]=="0":
                dp[i][j]=0
            else:
                dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1
                res=max(res,dp[i][j])
                
    return res*res           

maximalSquare([["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]])    
*********************************************************************************************************
def maximalRectangle(matrix):
    
    res=0
    dp=[0]*(len(matrix[0])) 
    
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            if matrix[i][j] == "1":
                dp[j] = dp[j]+1
            elif matrix[i][j] == "0":    
                dp[j] = 0
                
        res=max(largestRectangleArea(dp),res)
    
    return res
    
def largestRectangleArea(height):
    height.append(0)
    stack = [-1]
    ans = 0
    for i in range(len(height)):
        while height[i] < height[stack[-1]]:
            h = height[stack.pop()]
            w = i - stack[-1] - 1
            ans = max(ans, h * w)
        stack.append(i)
    height.pop()
    return ans      
    

maximalRectangle([["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]])    
*********************************************************************************************************
def isRectangleOverlap(rec1, rec2):
        
    #width
    w1=max(rec1[0],rec2[0])
    w2=min(rec1[2],rec2[2])
    #width=abs(w1-w2)
    if w2-w1>0:
        h1=max(rec1[1],rec2[1])
        h2=min(rec1[3],rec2[3])
        #hight
        if h2-h1>0:
            return True
        else:
            return False  
    else:
        return False
        
isRectangleOverlap([0,0,2,2],[1,1,3,3])
*********************************************************************************************************
def canCompleteCircuit(gas, cost):
        
    first_station = available_gas = overall = 0
    for i in range(len(gas)):
        available_gas += gas[i] - cost[i]
        overall += gas[i] - cost[i]
        if available_gas < 0:
            available_gas, first_station = 0, i + 1
    if overall >=0:
        return first_station 
    else:
        -1
     
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]        
canCompleteCircuit(gas, cost)
*********************************************************************************************************
def gameOfLife(board):
    
    def execute(live, num):
        if num == 1:
            if live < 2:
                return 2
            if 2 <= live <= 3:
                return 1
            if live > 3:
                return 2
        else:
            if live == 3:
                return -1
            else:
                return 0
    def search(i,j):
        live = 0
        for a in range(i-1,i+2):
            for b in range(j-1,j+2):
                if (a,b) != (i,j):
                    try:
                        if a >= 0 and b >= 0 and board[a][b] > 0:
                            live += 1
                    except:
                        pass
        board[i][j] = execute(live, board[i][j])


    m, n = len(board), len(board[0])
    for i in range(m):
        for j in range(n):
            search(i,j)

    for i in range(m):
        for j in range(n):
            if board[i][j] == 2:
                board[i][j] = 0
            if board[i][j] == -1:
                board[i][j] = 1
                
gameOfLife([
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
])                
*********************************************************************************************************
def prisonAfterNDays(arr, N):
    
    new = arr[:] #get a copy of the array
    n = len(arr)

    if n == 1: print [0] #when only 1 node, return [0]

    for _ in range(N):
        new[0] = arr[1] #determine the edge nodes first
        new[n - 1] = arr[n-2]

        for i in range(1, n-1):
            new[i] = 1 - (arr[i-1] == arr[i+1]) #logic for the rest nodes
        arr = new[:] #update the list for the next day

    return new

#[0,0,1,1,0,0,0,0]
cells = [0,1,0,1,1,0,0,1]
N = 7
prisonAfterNDays(cells, N)
*********************************************************************************************************
def prisonAfterNDays(cells, N):
    
    def nextday(cells):
        newcells =[]
        newcells.append(0)
        for i in range(1, len(cells)-1):
            if cells[i - 1] == cells[i + 1]:
                newcells.append(1)
            else:
                newcells.append(0)
        newcells.append(0)
        return newcells

    seen = {}
    while N > 0:
        c = tuple(cells)
        if c in seen:
            N %= seen[c] - N
        seen[c] = N

        if N >= 1:
            N -= 1
            cells = nextday(cells)

    return list(cells)
    
cells=[1,0,0,1,0,0,1,0]
N = 1000000000
prisonAfterNDays(cells, N)
*********************************************************************************************************
#brute force
def dailyTperatures(nums):
    res = [0] * len(nums)
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[j] > nums[i]:
                res[i] = j - i 
                break #guarentee the soonest 
    return res
    
dailyTperatures([73, 74, 75, 71, 69, 72, 76, 73]) 
#[1, 1, 4, 2, 1, 1, 0, 0]

def dailyTperatures(nums):
    res = [0] * len(nums)
	stack=[]
    for i in range(len(nums)):
		while stack and nums[i]>nums[stack[-1]]:
			cur=stack.pop()
			res[cur]=i-cur 
		stack.append(i)
		
	return res
    
dailyTperatures([73, 74, 75, 71, 69, 72, 76, 73]) 
#[1, 1, 4, 2, 1, 1, 0, 0]
*********************************************************************************************************
def mySqrt(x):
        
    l = 0
    h = x
    while l < r:
        mid = (l + h + 1) // 2
        if mid * mid == x:
            return mid
        elif mid * mid > x:
            h = mid - 1
        else:
            l = mid
    return r
    
mySqrt(9)    
*********************************************************************************************************
def minmoves(a,m):
    
    total_moves = 0
    
    for i in range(len(a)):
        num = cal_moves(a[i],m[i])
        total_moves += num
        
    return total_moves     
        
def cal_moves(x,y):
    moves =0
    while x>0 and y>0:
        last_x = x%10
        last_y = y%10
        moves += abs(last_x-last_y)
        x=x//10
        y=y//10
    return moves
    
minmoves([123,543],[321,279])    
*********************************************************************************************************
def decodeString(s):
    if not s:
        return ""
    stack=[]
        
    for i in s:
        if i != ']':
            stack.append(i)
        else:
            s1=""
            while stack and stack[-1] != "[":
                s1 = stack.pop() + s1
                
            stack.pop()
            n=""
            while stack and stack[-1].isdigit():
                n = stack.pop() + n 
            
            s2 = s1 * int(n)
            stack.extend(s2)
            
    return "".join(stack) 

decodeString("3[a]2[bc]")    
*********************************************************************************************************

def findElement(arr, n):  
   
    # leftMax[i] stores maximum of arr[0..i-1]  
    leftMax = [None] * n  
    leftMax[0] = float('-inf')  
  
    # Fill leftMax[]1..n-1]  
    for i in range(1, n):  
        leftMax[i] = max(leftMax[i-1], arr[i-1])  
  
    # Initialize minimum from right  
    rightMin = float('inf')  
  
    # Traverse array from right  
    for i in range(n-1, -1, -1):  
       
        # Check if we found a required element  
        if leftMax[i] < arr[i] and rightMin > arr[i]:  
            return i  
  
        # Update right minimum  
        rightMin = min(rightMin, arr[i])  
       
    # If there was no element matching criteria  
    return -1 
    
findElement([5, 1, 4, 3, 6, 8, 10, 7, 9],9 )    
*********************************************************************************************************
def numRescueBoats(people, limit):
    
    people = sorted(people)
    boat=0
    l=0
    h=len(people)-1
    
    while l<=h:
        if people[l]+people[h]<=limit:
            l+=1
            h-=1
        else:
            l+=1
        boat+=1    
     
numRescueBoats(people = [3,5,3,4], limit = 5) 

*********************************************************************************************************
def licenseKeyFormatting(self, S, K):
        
        res=""
        temp=""
        S = S.replace("-", "").upper()
        for i in range(len(S)-1,-1,-1):
            if len(temp)<K:
                    temp= S[i]+temp
                    
            if len(temp)==K:
                if res == "":
                    res+= temp
                    temp=""
                else:
                    res= temp + '-' + res
                    temp=""
                    
        if res=="":
            res+= temp
        elif temp:            
            res= temp + '-' + res              
                    
        return res
		
licenseKeyFormatting(S = "5F3Z-2e-9-w", K = 4)		

#"2-5g-3-J" k=2
*********************************************************************************************************
def nextClosestTime(time):
        s = set(time)
        hour = int(time[0:2])
        minute = int(time[3:5])
        while True:
            minute += 1
            if minute == 60:
                minute = 0
                 
				if hour == 23:
					hour = 0	
				else:
					hour += 1
            
            time = "%02d:%02d" % (hour, minute)
            temp=set(time)
            if set(time) <= s:
                return time
        return time
    
    

nextClosestTime("01:12")
*********************************************************************************************************
def isomorphic(s, t):
        mapping = {}
        set_ = set()
        for i in range(len(s)):
            
            if s[i] not in mapping and t[i] in set_:
                return False
            
            elif s[i] not in mapping:
                mapping[s[i]] = t[i]
                set_.add(t[i])
                
            elif mapping[s[i]] != t[i]:
                return False
            

        return True
isomorphic("ab","ca")   
*********************************************************************************************************
def wordPattern(pattern, str):
    
    str=str.split(" ")
    if len(str) != len(pattern):
        return False
    
    mapping = {}
    set_ = set()
    
    for i in range(len(pattern)):
        
        if pattern[i] not in mapping and str[i] in set_:
            return False
        
        elif pattern[i] not in mapping:
            mapping[pattern[i]] = str[i]
            set_.add(str[i])
            
        elif mapping[pattern[i]] != str[i]:
            return False
        
    return True
    
wordPattern(pattern = "abba", str = "dog cat cat fish")            
*********************************************************************************************************
def minAddToMakeValid(S):
	
	count = 0
	list_ = []
	for i in S:
		if i == '(':
			list_.append(i)
		elif i == ')':
			if list_ and list_[-1] == '(':
				list_.pop()
			else:
				count+=1
	
	
	return len(list_)+count
		
minAddToMakeValid("()))((")		

#without stack
def minAddToMakeValid(S):
    fCount = 0  # "(" count
    bCount = 0 # ")" count
    for s in S:
        if s == '(':
            fCount += 1
        else:
            if fCount == 0:
                bCount += 1
            else:
                fCount -= 1
    
    return bCount + fCount
    
        
minAddToMakeValid("())))")
*********************************************************************************************************
#sort linkedlist
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None
         
class Solution(object): 
    def __init__(self): 
        self.head = None
    
    def push(self, new_data): 
        new_node = ListNode(new_data) 
        new_node.next = self.head 
        self.head = new_node 
        

    def merge(self, h1, h2):
            dummy = tail = ListNode(None)
            while h1 and h2:
                if h1.val < h2.val:
                    tail.next, h1 = h1, h1.next
                else:
                    tail.next, h2 = h2, h2.next
                tail = tail.next
        
            tail.next = h1 or h2
            return dummy.next
        
    def sortList(self, head):
        if not head or not head.next:
            return head
    
        pre, slow, fast = None, head, head
        while fast and fast.next:
            pre, slow, fast = slow, slow.next, fast.next.next
        pre.next = None
        
        #main
        return self.merge(self.sortList(head),self.sortList(slow))
        
l1 = Solution()         

l1.push(3)                    
l1.push(1) 
l1.push(2) 
l1.push(4) 
    
l1.sortList(l1.head)        
*********************************************************************************************************
#494. Target Sum
import collections
        
def findTargetSumWays(nums, S):
        
    queue = {0:1}
    for n in nums:
        tmp = collections.defaultdict(int)
        for summary,cnt in queue.items():
            tmp[summary+n]+=cnt
            tmp[summary-n]+=cnt
        queue = tmp
        # print(queue)
    return queue[S]

findTargetSumWays([1, 1, 1, 1, 1],3)    
*********************************************************************************************************
class Node: 
    def __init__(self ,key): 
        self.val = key 
        self.left = None
        self.right = None
        
def findTarget(root, k):
    
        if not root:
            return False

        return _findTarget(root, set(), k)
    
def _findTarget(node, nodes, k):
    if not node:
        return False

    complement = k - node.val
    if complement in nodes:
        return True

    nodes.add(node.val)

    return _findTarget(node.left, nodes, k) or _findTarget(node.right, nodes, k)
    
root = Node(5) 
root.left = Node(3) 
root.right = Node(6) 
root.left.left = Node(2) 
root.left.right = Node(4) 
root.right.right= Node(7)

print(findTarget(root,9))         
*********************************************************************************************************
class Codec:

	def encode(self, strs):
		if len(strs) == 0:
			return ""
		else:
			#temp2 =  "//".join([s.replace("/", "#/#") for s in strs]) + "//"
			print("original string:"+ strs)
			encode_=""
			for i in strs:
				if i=="/":
					encode_+= "#/#" + "//"
				else:
					encode_ += i+"//"
			print("encoded string:"+ encode_)
			return encode_    
				

	def decode(self, s):
		if len(s) == 0:
			return []
		#return [seg.replace("#/#", "/") for seg in s.split("//")][:-1]
	   
		k=s.split("//")[:-1]
		decode_=""
		for j in k:
			if j=="#/#":
				decode_+=j.replace("#/#","/")  
			else:
				decode_+=j
		print("decoded string:"+ decode_)        
		return "".join(decode_)        
			

# Your Codec object will be instantiated and called as such:
codec = Codec()
codec.decode(codec.encode("123//abc"))
*********************************************************************************************************
class LinkedList():
     def __init__(self,key,value):
            self.key=key
            self.value=value
            self.next=None
    
class MyHashMap(object):

    def __init__(self):
        self.map=[None]*20
        

    def put(self, key, value):
        
        if self.map[key%10000] == None:
            self.map[key] = LinkedList(key,value)
        else:
            p= self.map[key]
            p.value=value
        return    

    def get(self, key):
        
        p = self.map[key%10000]
        if p == None:
            return -1
        else:
            if p.key == key:
                return p.value

    def remove(self, key):
        
        p = self.map[key%10000]
        if p == None:
            return
        if p.key == key:
            self.map[key%10000]=p.next
            return 
                

hashMap =  MyHashMap();
hashMap.put(1, 10);          
hashMap.put(2, 20);         
hashMap.get(1);            
hashMap.get(3);            
hashMap.put(2, 1);         
hashMap.get(2);             
hashMap.remove(2);        
hashMap.get(2);  
*********************************************************************************************************
#pascal triangle
def generate( numRows):
        
        triangle = []

        for row_num in range(numRows):
            # The first and last row elements are always 1.
            row = [None]*(row_num+1)
            row[0], row[-1] = 1, 1

            # Each triangle element is equal to the sum of the elements
            # above-and-to-the-left and above-and-to-the-right.
            for j in range(1, len(row)-1):
                row[j] = triangle[row_num-1][j-1] + triangle[row_num-1][j]

            triangle.append(row)

        return triangle
        
generate(5)        
*********************************************************************************************************
def numSquares(n):

    dp = [float("inf")]*(n+1)
    dp[1] = 1
    perfect = [1]
    for i in range(2,n+1) :
        if not i**0.5 - int(i**0.5) :
            dp[i] = 1
            perfect.append(i)
        else :            
            for j in perfect :
                dp[i] = min(dp[i], dp[i-j] + 1)
    return dp[-1]
    
numSquares(12)    

*********************************************************************************************************
def largestNumber(nums):
    nums = mergeSort(nums, 0, len(nums)-1)
    return str(int("".join(map(str, nums))))
    
def mergeSort(nums, l, r):
    if l > r:
        return 
    if l == r:
        return [nums[l]]
    mid = l + (r-l)//2
    left = mergeSort(nums, l, mid)
    right = mergeSort(nums, mid+1, r)
    return merge(left, right)
    
def merge( l1, l2):
    res, i, j = [], 0, 0
    while i < len(l1) and j < len(l2):
        if not compare(l1[i], l2[j]):
            res.append(l2[j])
            j += 1
        else:
            res.append(l1[i])
            i += 1
    res.extend(l1[i:] or l2[j:])
    return res
   
def compare(n1, n2):
    return str(n1) + str(n2) > str(n2) + str(n1)    
    
largestNumber([3,30,34,5,9])
#Output: "9534330"
*********************************************************************************************************
def validMountainArray(A):
        
    if len(A)<3:
        return False
    
    i=0
    while i<len(A) and (i+1) < len(A) and A[i+1]>A[i]:
        i+=1
    
    if i==0 or (i+1)>=len(A):
        return False 
        
    while i<len(A) and (i+1) < len(A):
        if A[i]<=A[i+1]:
            return False
        i+=1    
    
    return True        
            
validMountainArray([0,1,2,3,4,5,6,7,8,9])        
*********************************************************************************************************
import heapq
def getSkyline( buildings):
    v_lines = {l for b in buildings for l in (b[0],b[1])}
    heap, i, res = [], 0, []
    for vl in sorted(v_lines):
	
		#start of the bulding
        while i < len(buildings) and buildings[i][0] <= vl:
            heapq.heappush(heap, (-buildings[i][2], buildings[i][1]))
            i+=1
			
		#pop all who ends at or before this position	
        while heap and heap[0][1] <= vl:
            heapq.heappop(heap)
		
		#calculate hight	
        h = len(heap) and -heap[0][0]
		
        if not res or res[-1][1]!= h:
            res.append((vl, h))
    return res
    
getSkyline([[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]])    
*********************************************************************************************************
#max 2 number
def removeDuplicates(nums):
        
    if not nums:
        return 0
        
    start = nums[0]
    index = 1
    flag = True
    
    while index <= len(nums)-1:
        
        if nums[index] == start:
            if flag == True:
                flag = False
            else:
                del nums[index]
                index-=1
        else:
            start = nums[index]
            flag = True
            
        index+=1    
     
    return len(nums)
        
removeDuplicates([1,1,1,2,2,3])        
*********************************************************************************************************
def majorityElementII(nums):
    
    num1, num2 = 0,0
    c1, c2 = 0,0
    r = []
    for i in nums:
        if i == num1:
            c1 += 1
        elif i == num2:
            c2 += 1
        elif c1 == 0:
            num1 = i
            c1 = 1
        elif c2 == 0:
            num2 = i
            c2 = 1
        else:
            c1 -= 1
            c2 -= 1
    # verify if the elements found are the majority numbers
    c1 = 0
    c2 = 0
    for j in nums:
        if j == num1:
            c1 += 1
        elif j == num2:
            c2 += 1
    l = len(nums)
    if c1 > l/3:
        r.append(num1)
    if c2 > l/3:
        r.append(num2)
    return r
    
majorityElementII([1,1,1,3,3,2,2,2])    
*********************************************************************************************************
import heapq

class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None
           
class Solution:
  
    def mergeKLists(self, lists):
        dummy = ListNode(0)
        current = dummy

        heap = []
        for sorted_list in lists:
            if sorted_list:
                heapq.heappush(heap, (sorted_list.val, sorted_list))

        while heap:
            smallest = heapq.heappop(heap)[1]
            current.next = smallest
            current = current.next
            if smallest.next:
                heapq.heappush(heap, (smallest.next.val, smallest.next))

        return dummy.next


if __name__ == "__main__":
    list1 = ListNode(1)
    list1.next = ListNode(3)
    list2 = ListNode(2)
    list2.next = ListNode(4)

    print (Solution().mergeKLists([list1, list2]))
*********************************************************************************************************
#Time Complexity: O(N+E). Space: O(N).
class Node(object):
    def __init__(self, val):
        self.val = val
        self.neighbors = []

class Solution(object):
    
    def cloneGraph(self, node):
        nodeMap = {}
        return self.dfs(node, nodeMap)
    
    def dfs(self, node, nodeMap):
        if node == None:
            return None
        if node.val in nodeMap:
            return nodeMap[node.val]
        newNode = Node(node.val)
        nodeMap[node.val] = newNode
        for neighbor in node.neighbors:
            newNode.neighbors.append(self.dfs(neighbor, nodeMap))
        return newNode

node1 = Node("A");
node2 = Node("B");
node3 = Node("C");
node4 = Node("D");      
    
node1.neighbors.append(node2);
node1.neighbors.append(node3);
node2.neighbors.append(node4);
node4.neighbors.append(node3);
clone=Solution()  
     
clone.cloneGraph(node1)
*********************************************************************************************************
class Node: 
    def __init__(self, data): 
        self.val = data  
        self.left = None
        self.right = None
      
def convertBST(root):
        
        def addSum(node, sum_parent):
            if node.right:
                sum_parent = addSum(node.right, sum_parent)
            node.val += sum_parent
            if node.left:
                return addSum(node.left, node.val)
            return node.val

        if root:
            addSum(root, 0)
        return root    
    
        
root1 = Node(5) 
root1.left = Node(2) 
root1.right = Node(13) 

convertBST(root1)
*********************************************************************************************************
#nlogn
def myPow(x, n):
    if n == 0:
        return 1
    if n < 0:
        return 1/myPow(x, -n)
    if n%2:
        return x* myPow(x, n-1)
    else:
        return myPow(x*x, n/2)
        
myPow(2.00000, 10)
*********************************************************************************************************
#Binary Search Tree Iterator
#logn

class Node(object):
        def __init__(self, x):
            self.val = x
            self.left = None
            self.right = None

class BSTIterator(object):

    def __init__(self, root):
        self.stack = []
        self.helper(root)
        
    def helper(self, root):
        while root:
            self.stack.append(root)
            root = root.left
    
    # @return a boolean, whether we have a next smallest number
    def hasNext(self):
        return self.stack  # or self.stack != []
    
    # @return an integer, the next smallest number
    def next(self):
        node = self.stack.pop()
        self.helper(node.right)
        return node.val
        
root = Node(7) 
root.left = Node(3) 
root.right = Node(15) 
root.right.left = Node(9)
root.right.right = Node(20)

iterator = BSTIterator(root)

iterator.next();    #// return 3
iterator.next();    #// return 7
iterator.hasNext(); #// return true
iterator.next();    #// return 9
iterator.hasNext(); #// return true
iterator.next();    #// return 15
iterator.hasNext(); #// return true
iterator.next();    #// return 20
iterator.hasNext(); #// return false     
*********************************************************************************************************
## log(n) + k
class Node(object):
        def __init__(self, x):
            self.val = x
            self.left = None
            self.right = None

def kthSmallest(root, k):
    stack = []
    while True:
        while root:
            stack.append(root)
            root = root.left
        if not stack:
            return 
      
        node = stack.pop()
        k -= 1
        if k == 0:
            return node.val
        root = node.right
    
        
root = Node(7) 
root.left = Node(3) 
root.right = Node(15) 
root.right.left = Node(9)
root.right.right = Node(20)
kthSmallest(root,1)
*********************************************************************************************************
https://baihuqian.github.io/2018-08-02-sparse-matrix-multiplication/
*********************************************************************************************************
# 437 sumpath3
class Node: 
    def __init__(self ,key): 
        self.val = key 
        self.left = None
        self.right = None
  
def pathSum(root, total):
        if not root:
            return 0
        
        stack = [(root, [root.val])]
        num = 0
        
        while stack:
            node, totals = stack.pop()
            
            num += totals.count(total)
                
            if node.left:
                stack.append((node.left, [x+node.left.val for x in totals]+[node.left.val]))
            if node.right:
                stack.append((node.right, [x+node.right.val for x in totals]+[node.right.val]))
        return num
  
root = Node(10) 
root.left = Node(5) 
root.right = Node(-3) 
root.left.left = Node(3) 
root.left.right = Node(2) 
root.right.right= Node(11)
root.left.left.left = Node(3)
root.left.left.right = Node(-2)
root.left.right.right = Node(1)
print(pathSum(root,8)) 
*********************************************************************************************************
class Codec:

    def __init__(self):
        self.dict_={}
        
    def encode(self, longUrl):
        self.dict_[hash(longUrl)]=longUrl
        return hash(longUrl) 

    def decode(self, shortUrl):
        return self.dict_[shortUrl]
        

codec = Codec()
codec.decode(codec.encode("https://leetcode.com/problems/design-tinyurl"))
*********************************************************************************************************
def fourSumCount( A, B, C, D):
    ans = 0
    sum_ab = {}
    for a in A:
        for b in B:
            anb = a+b
            if anb in sum_ab:
                sum_ab[anb] += 1
            else:
                sum_ab[anb] = 1
    for c in C:
        for d in D:
            cnd = -c-d
            if cnd in sum_ab:
                ans += sum_ab[cnd]      
    return ans

fourSumCount(A = [ 1, 2],B = [-2,-1],C = [-1, 2],D = [ 0, 2])    
*********************************************************************************************************
output=[]
def removNestings(l): 
    for i in l: 
        if type(i) == list: 
            reemovNestings(i) 
        else: 
            output.append(i) 
  
reemovNestings([1, 2, [3, 4, [5, 6]], 7, 8, [9, [10]]]) 
*********************************************************************************************************
def maxProduct(nums):
    if not nums:
        return 
    locMin = locMax = gloMax = nums[0]
    for i in range(1, len(nums)):
        tmp = locMin
        locMin = min(locMin*nums[i], nums[i], locMax*nums[i])
        locMax = max(tmp*nums[i], nums[i], locMax*nums[i])
        gloMax = max(gloMax, locMax)
    return gloMax

maxProduct([2,3,-2,4])    
*********************************************************************************************************
def maximumProduct(nums):
        nums= sorted(nums)
        res = []
        
        for i in range(len(nums)):
            L = i+1
            R = len(nums)-1
            while L < R:
                temp = nums[i] * nums[L] * nums[R]
                res.append(temp)
                L+=1       
        return max(res)  
maximumProduct([9,1,5,6,7,2])
*********************************************************************************************************
def validPalindrome(s):
    
    for i in range(len(s)):
        t = s[:i] + s[i+1:]
        if t == t[::-1]: 
            return True

    return s == s[::-1]
	
validPalindrome("abca")	
 
*********************************************************************************************************
def validPalindrome(s):
    
    if s == s[::-1]:
        return True

    l=0
    h=len(s)-1
    
    while l<h:
        if s[l] != s[h]:
            return ispalindrome(s,l+1,h) or ispalindrome(s,l,h-1)
        
        l+=1
        h-=1
        
    return True    
    
    
def ispalindrome(s,l,h):
    while l<h:
        if s[l] != s[h]:
            return False
        
        l+=1
        h-=1
        
    return True 
        

validPalindrome("atbbga")    
*********************************************************************************************************
def maxDifference(arr):
    n=len(arr)
    res = float('-inf')
    minNum = arr[0]
    for num in arr[1:]:
        if num > minNum:
            res = max(res, num - minNum)
        minNum = min(minNum, num)
    return res if res != float('-inf') else -1
    
        
maxDifference([7,2,3,10,2,4,8,1])        
*********************************************************************************************************
def dailyTemperatures(nums):
    
    res=[0]*len(nums)
    s=[]
    for i in range(len(nums)):
        while s and nums[i] > nums[s[-1]]:
            cur  = s.pop()
            res[cur] = i - cur
        
        s.append(i)  
            
    return res
    
dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73])    


"""T = [73, 74, 75, 71, 69, 72, 76, 73],
[1, 1, 4, 2, 1, 1, 0, 0].

""" 
*********************************************************************************************************
*********************************************************************************************************
*********************************************************************************************************
*********************************************************************************************************
*********************************************************************************************************
       